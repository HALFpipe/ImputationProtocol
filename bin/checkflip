#!/usr/bin/env python3

from __future__ import annotations
from typing import Optional, Literal, Union

import re
import gzip
from argparse import ArgumentParser
from dataclasses import dataclass, field
import logging
from math import nan, isfinite
from subprocess import call
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor
from glob import glob

logger = logging.getLogger("checkflip")


def verbose_call(command: list[str]):
    logger.info(f"Running command line {command}")
    call(command)


Chromosome = Union[int, Literal["X"]]


def parse_chromosome(chromosome_str: str) -> Optional[Chromosome]:
    if chromosome_str == "X":
        chromosome: Chromosome = "X"
    elif chromosome_str.isdigit():
        chromosome = int(chromosome_str)

        if chromosome == 23:
            chromosome = "X"
        elif chromosome > 23:
            return None
    else:
        return None

    return chromosome


@dataclass
class MatchResult:
    variant: Optional[Variant] = None
    messages: list[str] = field(default_factory=list)


@dataclass
class Variant:
    id: str

    chromosome: Chromosome
    position: Optional[int]

    allele_a: str
    allele_b: str

    frequency_a: float
    frequency_b: float

    n_observations: Optional[int] = None

    actions: list[str] = field(default_factory=list)

    def copy(self):
        return Variant(
            id=self.id,
            chromosome=self.chromosome,
            position=self.position,
            allele_a=self.allele_a,
            allele_b=self.allele_b,
            frequency_a=self.frequency_a,
            frequency_b=self.frequency_b,
            n_observations=self.n_observations,
            actions=[*self.actions],
        )

    @property
    def alleles(self) -> tuple[str, str]:
        return (self.allele_a, self.allele_b)

    @property
    def genotype(self) -> frozenset:
        return frozenset([self.allele_a, self.allele_b])

    @property
    def counts(self) -> tuple[int, int]:
        assert self.n_observations is not None
        allele_a_count = round(self.frequency_a * self.n_observations)
        return (allele_a_count, self.n_observations - allele_a_count)

    @property
    def is_indel(self) -> bool:
        return len(self.allele_a) != len(
            self.allele_b
        ) or self.genotype.issubset(["I", "D", "0"])

    @property
    def is_ambiguous(self) -> bool:
        return self.genotype in frozenset(
            [
                frozenset(["A", "T"]),
                frozenset(["C", "G"]),
            ]
        )

    def flip(self) -> Optional[Variant]:
        flip_dict = {
            "A": "T",
            "C": "G",
            "T": "A",
            "G": "C",
            "0": "0",
        }

        if self.allele_a not in flip_dict or self.allele_b not in flip_dict:
            return None

        flipped = self.copy()

        flipped.allele_a = flip_dict[self.allele_a]
        flipped.allele_b = flip_dict[self.allele_b]

        flipped.actions.append("flip")

        return flipped

    def turn(self) -> Variant:
        turned = self.copy()

        turned.allele_a = self.allele_b
        turned.allele_b = self.allele_a

        turned.frequency_a = self.frequency_b
        turned.frequency_b = self.frequency_a

        turned.actions.append("turn")

        return turned

    def equals_alleles(self, other: Variant) -> bool:
        return self.alleles == other.alleles

    def match_alleles(self, other: Variant) -> MatchResult:
        assert self.chromosome == other.chromosome
        assert self.position == other.position

        if not isfinite(self.frequency_a):
            return MatchResult(messages=[(f"frequency_{self.frequency_a}")])

        if self.is_ambiguous:
            return self.match_alleles_ambiguous(other)

        if self.is_indel:
            if not other.is_indel:
                return MatchResult(messages=[("indel_mismatch")])

            if self.genotype.issubset(frozenset(["I", "D", "0"])):
                return self.match_alleles_indel(other)

        messages = []

        if "0" in self.genotype:
            return self.match_alleles_incomplete(other)

        if self.equals_alleles(other):
            return MatchResult(variant=self)

        messages.append("allele_mismatch")

        turned = self.turn()
        if turned.equals_alleles(other):
            return MatchResult(variant=turned)

        if "flip" not in self.actions:
            flipped = self.flip()
            if flipped is not None:
                return flipped.match_alleles(other)
            messages.append("cannot_flip")

        return MatchResult(messages=messages)

    def match_alleles_indel(self, other: Variant) -> MatchResult:
        filled = self.copy()
        filled.actions.append("fill_indel")

        filled.allele_a = other.allele_a
        filled.allele_b = other.allele_b

        if len(other.allele_a) > len(other.allele_b):
            # other.allele_a is the insertion
            if self.allele_a == "I":
                if self.allele_b == "D" or self.allele_b == "0":
                    return MatchResult(variant=filled)
            elif self.allele_a == "D":
                if self.allele_b == "I" or self.allele_b == "0":
                    return MatchResult(variant=filled.turn())
            elif self.allele_a == "0":
                if self.allele_b == "I":
                    return MatchResult(variant=filled.turn())
                elif self.allele_b == "D":
                    return MatchResult(variant=filled)
        else:
            # other.allele_b is the insertion
            if self.allele_a == "I":
                if self.allele_b == "D" or self.allele_b == "0":
                    return MatchResult(variant=filled.turn())
            elif self.allele_a == "D":
                if self.allele_b == "I" or self.allele_b == "0":
                    return MatchResult(variant=filled)
            elif self.allele_a == "0":
                if self.allele_b == "I":
                    return MatchResult(variant=filled)
                elif self.allele_b == "D":
                    return MatchResult(variant=filled.turn())

        return MatchResult(messages=["indel_mismatch"])

    def match_alleles_ambiguous(self, other: Variant) -> MatchResult:
        if self.genotype != other.genotype:
            return MatchResult(messages=[("allele_mismatch")])

        ambiguous_matched = None

        if abs(self.frequency_a - other.frequency_a) > abs(
            self.frequency_b - other.frequency_a
        ):
            if self.equals_alleles(other):
                flipped = self.flip()
                if flipped is None:
                    return MatchResult(messages=["cannot_flip"])
                ambiguous_matched = flipped.turn()
            else:
                ambiguous_matched = self.turn()

        else:
            if self.equals_alleles(other):
                ambiguous_matched = self
            else:
                ambiguous_matched = self.flip()

        assert ambiguous_matched is not None

        if (
            abs(ambiguous_matched.frequency_a - 0.5) > args.sfh * 0.5
            and abs(other.frequency_a - 0.5) > args.sfh * 0.5
        ):
            return MatchResult(variant=ambiguous_matched)

        return MatchResult(messages=["ambiguous_insecure"])

    def match_alleles_incomplete(self, other: Variant) -> MatchResult:
        filled = self.copy()
        filled.actions.append("fill")

        if self.allele_a == "0" and self.allele_b == other.allele_b:
            filled.allele_a = other.allele_a
            return filled.match_alleles(other)

        if self.allele_a == "0" and self.allele_b == other.allele_a:
            filled.allele_a = other.allele_b
            return filled.match_alleles(other)

        if self.allele_a == other.allele_a and self.allele_b == "0":
            filled.allele_b = other.allele_b
            return filled.match_alleles(other)

        if self.allele_a == other.allele_b and self.allele_b == "0":
            filled.allele_b = other.allele_a
            return filled.match_alleles(other)

        if "flip" not in self.actions:
            flipped = self.flip()
            if flipped is None:
                return MatchResult(messages=["cannot_flip"])
            return flipped.match_alleles_incomplete(other)

        return MatchResult(messages=["incomplete", "allele_mismatch"])


if __name__ == "__main__":
    parser = ArgumentParser()
    parser.add_argument("--bfile", type=str, required=True)
    parser.add_argument("--population", type=str, required=True)
    parser.add_argument(
        "--legends", action="extend", nargs="+", type=str, required=False
    )
    parser.add_argument("--sfh", type=float, default=0.2)
    parser.add_argument("--log-level", type=str, default="INFO")

    args = parser.parse_args()

    logging.basicConfig(level=args.log_level)

    chromosome_regex = re.compile(r"chr(?P<chromosome>\d+|X|Y)")

    if args.legends is None or len(args.legends) == 0:
        args.legends = glob(
            "/data/cloudgene/apps/1000g-phase-3-v5/2.0.0/"
            "legends/ALL_1000G_phase3_integrated_v5_chr*.legend.gz"
        )
        if len(args.legends) == 0:
            raise FileNotFoundError(
                "Could not find legend files. "
                "Please check if the imputation server is installed correctly "
                "or manually specify the legend files with the "
                '"--legends" argument'
            )

    # read sample

    afreq_file = f"{args.bfile}.afreq"
    if not Path(afreq_file).exists():
        verbose_call(
            [
                "plink2",
                "--bfile",
                args.bfile,
                "--out",
                args.bfile,
                "--freq",
                "--nonfounders",
            ]
        )

    sample_variants_by_id = dict()
    with open(afreq_file, "rt") as afreq_file_handle:
        logger.info(f'Reading "{afreq_file}"')

        header = afreq_file_handle.readline()
        columns = header.split()

        assert columns[0] == "#CHROM"
        assert columns[1] == "ID"
        assert columns[2] == "REF"
        assert columns[3] == "ALT"
        assert columns[4] == "ALT_FREQS"
        assert columns[5] == "OBS_CT"

        for line in afreq_file_handle:
            (
                chromosome_str,
                id,
                allele_ref,
                allele_alt,
                alt_freq_str,
                n_observations_str,
            ) = line.split()

            # use plink 1.9 missing codes

            if allele_ref == ".":
                allele_ref = "0"

            if allele_alt == ".":
                allele_alt = "0"

            # convert freq

            if alt_freq_str == "NA":
                alt_freq = nan
            else:
                alt_freq = float(alt_freq_str)

            n_observations = int(n_observations_str)

            # parse chromosome

            chromosome = parse_chromosome(chromosome_str)

            if chromosome is None:
                continue

            variant = Variant(
                id=id,
                chromosome=chromosome,
                position=None,
                allele_a=allele_ref,
                allele_b=allele_alt,
                frequency_a=1 - alt_freq,
                frequency_b=alt_freq,
                n_observations=n_observations,
            )

            assert id not in sample_variants_by_id
            sample_variants_by_id[id] = variant

    bim_file = f"{args.bfile}.bim"
    sample_variants: list[Variant] = list()
    with open(bim_file, "rt") as bim_file_handle:
        logger.info(f'Reading "{bim_file}"')

        for line in bim_file_handle:
            chromosome_str, id, _, position, allele_a, allele_b = line.split()

            # use plink 1.9 missing codes

            if allele_a == ".":
                allele_a = "0"

            if allele_b == ".":
                allele_b = "0"

            # parse chromosome

            chromosome = parse_chromosome(chromosome_str)

            if chromosome is None:
                continue

            variant = sample_variants_by_id[id]
            variant.position = int(position)

            assert variant.chromosome == chromosome

            if variant.alleles == (allele_a, allele_b):
                pass
            elif variant.alleles == (allele_b, allele_a):
                variant = variant.turn()
            else:
                raise ValueError(
                    f'Mismatch between "{afreq_file}" and "{bim_file}"'
                )

            assert variant.allele_a == allele_a
            assert variant.allele_b == allele_b

            sample_variants.append(variant)

    # read reference

    def read_legend_file(
        legend_file: str
    ) -> Optional[dict[str, list[Variant]]]:
        match = chromosome_regex.search(legend_file)

        if match is None:
            logger.info(
                f'Skipping legend file "{legend_file}" '
                "because the chromosome cannot be read from the file name"
            )
            return None

        chromosome_str = match.group("chromosome")

        chromosome = parse_chromosome(chromosome_str)

        if chromosome is None:
            logger.info(
                f"Skipping chromosome {chromosome_str} "
                f'legend file "{legend_file}"'
            )
            return None

        legend_file_variants: dict[str, list[Variant]] = dict()
        legend_file_variant_count = 0

        with gzip.open(legend_file, "rt") as legend_file_handle:
            header = legend_file_handle.readline()
            columns = header.split()

            assert columns[0] == "id"
            assert columns[1] == "position"
            assert columns[2] == "a0"
            assert columns[3] == "a1"

            aaf_column_name = f"{args.population}.aaf"
            aaf_column_index = columns.index(aaf_column_name)

            for line in legend_file_handle:
                values = line.split()
                id, position, allele_a, allele_b = values[:4]
                aaf = float(values[aaf_column_index])

                variant = Variant(
                    id=id,
                    chromosome=chromosome,
                    position=int(position),
                    allele_a=allele_a,
                    allele_b=allele_b,
                    frequency_a=1 - aaf,
                    frequency_b=aaf,
                )

                position_str = f"{chromosome}:{variant.position:d}"
                if position_str not in legend_file_variants:
                    legend_file_variants[position_str] = list()
                legend_file_variants[position_str].append(variant)
                legend_file_variant_count += 1

        logger.info(
            f"Using {legend_file_variant_count:d} variants "
            f'for chromosome {chromosome} from legend file "{legend_file}"'
        )

        return legend_file_variants

    # use multithreading to hide latency
    with ThreadPoolExecutor() as executor:
        reference_variants: dict[str, list[Variant]] = dict()
        for legend_file_variants in executor.map(
            read_legend_file, args.legends
        ):
            if legend_file_variants is not None:
                reference_variants |= legend_file_variants

    # match sample and reference
    counters = dict(not_in_reference=0)

    exclude = list()
    flip = list()
    update_alleles = list()

    for sample_variant in sample_variants:
        position_str = (
            f"{sample_variant.chromosome}:{sample_variant.position:d}"
        )

        if (
            position_str not in reference_variants
            or len(reference_variants[position_str]) == 0
        ):
            exclude.append(sample_variant.id)
            logger.debug(
                f"Excluding variant {sample_variant.id} "
                "because it could not be found in the reference"
            )
            counters["not_in_reference"] += 1
            continue

        reference_variant = None
        for reference_variant in reference_variants[position_str]:
            match_result = sample_variant.match_alleles(reference_variant)
            if match_result.variant is not None:
                break

        matched_variant = match_result.variant

        if matched_variant is None or len(match_result.messages) > 0:
            print_variant = matched_variant
            if print_variant is None:
                print_variant = sample_variant
            exclude.append(sample_variant.id)
            logger.debug(
                f"Excluding variant \n{print_variant} "
                "because it could not be matched to the reference variants \n"
                + "\n".join(map(str, reference_variants[position_str]))
                + f" with messages {match_result.messages}"
            )
            for message in match_result.messages:
                if message not in counters:
                    counters[message] = 0
                counters[message] += 1
            continue

        is_turned = False
        for action in matched_variant.actions:
            if action == "turn":
                is_turned = not is_turned
            elif action == "flip":
                flip.append(sample_variant.id)
            elif action == "fill":
                pass  # we leave this up to the imputation step
            elif action == "fill_indel":
                new_alleles = matched_variant.alleles
                if is_turned:
                    allele_a, allele_b = new_alleles
                    new_alleles = allele_b, allele_a
                with_missing_alleles = tuple((
                    new if old not in frozenset(["0"]) else old
                    for old, new in zip(sample_variant.alleles, new_alleles)
                ))  # don't overwrite missing values
                update_alleles.append(
                    (
                        sample_variant.id,
                        *sample_variant.alleles,
                        *with_missing_alleles,
                    )
                )

    del reference_variants

    # write out
    prefix = f"{args.bfile}.checkflip"

    counters_file = f"{prefix}.counters.txt"
    counters_lines = sorted(counters.items(), key=lambda item: item[-1])
    with open(counters_file, "wt") as counters_file_handle:
        counters_file_handle.write(
            "\n".join(
                f"{key}\t{value:d}" for key, value in counters_lines
            ) + "\n"
        )

    exclude_file = f"{prefix}.snp.exclude.txt"
    with open(exclude_file, "wt") as exclude_file_handle:
        exclude_file_handle.write("\n".join(exclude) + "\n")

    flip_file = f"{prefix}.snp.flip.txt"
    with open(flip_file, "wt") as flip_file_handle:
        flip_file_handle.write("\n".join(flip) + "\n")

    update_alleles_file = f"{prefix}.snp.update_alleles.txt"
    with open(update_alleles_file, "wt") as ua_file_handle:
        ua_file_handle.write("\n".join(map("\t".join, update_alleles)) + "\n")

    # apply
    verbose_call(
        [
            "plink",
            "--update-alleles",
            update_alleles_file,
            "--bfile",
            args.bfile,
            "--exclude",
            exclude_file,
            "--flip",
            flip_file,
            "--out",
            prefix,
            "--make-bed",
        ]
    )
